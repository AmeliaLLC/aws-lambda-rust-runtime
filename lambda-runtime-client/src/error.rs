//! This module defines the `RuntimeApiError` trait that developers should implement
//! to send their custom errors to the AWS Lambda Runtime Client SDK. The module also
//! defines the `ApiError` type returned by the `RuntimeClient` implementations.
use failure::Fail;
use http::StatusCode;
use std::io;

use client::LambdaHeaders;
use http::header::ToStrError;
use hyper;
use serde_json;

/// Error type description for the `ErrorResponse` event. This type should be returned
/// for errors that were handled by the function code or framework.
pub const ERROR_TYPE_HANDLED: &str = "Handled";
/// Error type description for the `ErrorResponse` event. This type is used for unhandled,
/// unexpcted errors.
pub const ERROR_TYPE_UNHANDLED: &str = "Unhandled";

/// This object is used to generate requests to the Lambda Runtime APIs.
/// It is used for both the error response APIs and fail init calls.
/// custom error types should implement the `RuntimeError` trait and return
/// this object to be compatible with the APIs.
#[derive(Serialize)]
pub struct ErrorResponse {
    /// The error message generated by the application.
    #[serde(rename = "errorMessage")]
    pub error_message: String,
    /// The error type for Lambda. This can be `Handled` or `Unhandled`.
    /// The `ERROR_TYPE_HANDLED` and `ERROR_TYPE_UNHANDLED`
    /// constants can to populate this field.
    #[serde(rename = "errorType")]
    pub error_type: String,
    /// The stack trace for the exception as vector of strings. In the framework,
    /// this value is automatically populated using the `backtrace` crate.
    #[serde(rename = "stackTrace")]
    pub stack_trace: Option<Vec<String>>,
}

impl ErrorResponse {
    /// Creates a new `RuntimeError` object with the handled error type.
    ///
    /// # Arguments
    ///
    /// * `message` The error message for the Lambda Runtime APIs.
    ///
    /// # Return
    /// A populated `RuntimeError` object that can be used with the Lambda Runtime API.
    pub fn handled(message: String) -> ErrorResponse {
        ErrorResponse {
            error_message: message,
            error_type: String::from(ERROR_TYPE_HANDLED),
            stack_trace: Option::default(),
        }
    }

    /// Creates a new `RuntimeError` object with the unhandled error type.
    ///
    /// # Arguments
    ///
    /// * `message` The error message for the Lambda Runtime APIs.
    ///
    /// # Return
    /// A populated `RuntimeError` object that can be used with the Lambda Runtime API.
    pub fn unhandled(message: String) -> ErrorResponse {
        ErrorResponse {
            error_message: message,
            error_type: String::from(ERROR_TYPE_UNHANDLED),
            stack_trace: Option::default(),
        }
    }
}

/// Custom errors for the framework should implement this trait. The client calls
/// the `to_response()` method automatically to produce an object that can be serialized
/// and sent to the Lambda Runtime APIs.
pub trait RuntimeApiError {
    /// Creates a `RuntimeError` object for the current error. This is
    /// then serialized and sent to the Lambda runtime APIs.
    ///
    /// # Returns
    /// A populated `RuntimeError` object.
    fn to_response(&self) -> ErrorResponse;
}

/// Represents an error generated by the Lambda Runtime API client.
#[derive(Fail, Debug)]
pub enum ApiError {
    #[fail(display = "A contextual error message: {}", _0)]
    BadStatus(StatusCode),

    #[fail(display = "{}", _0)]
    Unrecoverable(&'static str),

    #[fail(display = "{}", _0)]
    Hyper(#[fail(cause)] hyper::Error),

    #[fail(display = "{}", _0)]
    Json(#[fail(cause)] serde_json::Error),

    #[fail(display = "{}", _0)]
    Io(#[fail(cause)] io::Error),

    #[fail(display = "{}", _0)]
    ToStr(#[fail(cause)] ToStrError),

    #[fail(display = "{}", _0)]
    InvalidUri(#[fail(cause)] http::uri::InvalidUri),

    #[fail(display = "Missing header: {}", _0)]
    MissingHeader(LambdaHeaders),

    #[fail(display = "Unable to parse: {}", _0)]
    ParseIntError(std::num::ParseIntError),
}

impl ApiError {
    pub fn is_recoverable(&self) -> bool {
        match self {
            ApiError::Unrecoverable(_) => false,
            _ => true,
        }
    }
}

impl RuntimeApiError for ApiError {
    fn to_response(&self) -> ErrorResponse {
        let backtrace = format!("{:?}", self.backtrace());
        let trace_vec = backtrace.lines().map(|s| s.to_string()).collect::<Vec<String>>();
        let mut err = ErrorResponse::unhandled(self.to_string());
        err.stack_trace = Option::from(trace_vec);

        err
    }
}
